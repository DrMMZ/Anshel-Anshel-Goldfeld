import re
import getpass

# Throughout the codes, we denote by F(a,b) a free group of rank 2 generated by the set {a,b} where a^{-1} = A and b^{-1} = B.

# I. Preliminary. We define some functions as follows.

# 1. reduce(W) freely reduces a word W in F(a,b).
# Ex. Let W = baABa be a word in F(a,b). Then reduce(W) = a.
def reduce(W) :
    while True :
        if "aA" in W :
            i = W.find("aA")
            W = W[0:i] + W[i+2:]
            #print("aA at",i,"reduced to",W)
        elif "Aa" in W :
            i = W.find("Aa")
            W = W[0:i] + W[i+2:]
            #print("Aa at",i,"reduced to",W)
        elif "bB" in W :
            i = W.find("bB")
            W = W[0:i] + W[i+2:]
            #print("bB at",i,"reduced to",W)
        elif "Bb" in W :
            i = W.find("Bb")
            W = W[0:i] + W[i+2:]
            #print("Bb at",i,"reduced to",W)
        else :
            break
    #print("Reduced:",W)
    return W

# 2. inverse(W) finds the inverse of a word W in F(a,b).
# Ex. Let W = baABa be a word in F(a,b). Then inverse(W) = AbaAB.
def inverse(W) :
    W = W[::-1] # Reverse the order of W
    #print(W)
    W1 = str()
    for x in W :
        if x is "A" :
            y = x.lower()
            #print(x,"lower to",y)
            W1 = W1 + y
        if x is "B" :
            y = x.lower()
            #print(x,"lower to",y)
            W1 = W1 + y
        if x is "a" :
            X = x.upper()
            #print(x,"upper to",X)
            W1 = W1 + X
        if x is "b" :
            X = x.upper()
            #print(x,"upper to",X)
            W1 = W1 + X
    #print("Inverse:",W1)
    return W1

# 3. conjugate(x,y) finds the conjugation of x by y in F(a,b), denoted by x^{y} = yxy^{-1}.
# Ex. Let x = A and y = baABa be words in F(a,b). Then conjugate(x,y) = baABaAAbaAB.
def conjugate(x,y) :
    w = y + x + inverse(y)
    #print("Conjugation of",x,"by",y,"is",w)
    return w

# 4. f(s) converts a string s to a word in F(a,b) where s = k_{1}w_{1}...k_{n}w_{n} for some positive integer k_{i} and word w_{i} in F(a,b) for all 1 <= i <= n.
# Ex. Let s = 3a2Ab. Then f(s) = aaaAbAb.
def f(s) :
    L = re.findall("[0-9]+[abAB]+",s)
    L1 = list()
    K = list()
    W = list()
    for x in L :
        #print(x)
        k = re.findall("[0-9]+",x)
        k = int(k[0])
        #print(k)
        K.append(k) # K = {k_{1},...,k_{n}}
        w = re.findall("[abAB]+",x)
        w = w[0]
        #print(w)
        W.append(w) # W = {w_{1},...,w_{n}}
        w1 = k * w # w1 = w^{k}
        #print(w1)
        L1.append(w1)
    word = "".join(L1)
    #print("The word in F(a,b):",word)
    #print("Words and powers:",W,K)
    return word, W, K

# II. The Anshel-Anshel-Goldfeld protocol in F(a,b).

print()
print("------------------------------------------------------------")
print("  The Anshel-Anshel-Goldfeld public key exchange protocol   ")
print("using the free group F(a,b) where a^{-1} = A and b^{-1} = B.")
print("------------------------------------------------------------")
print()

# 1. Public: F(a,b), A = {a_{1},...,a_{n}} and B = {b_{1},...,b_{m}} sets of words in F(a,b).
while True:
    Gp = input("Confirm the group: ")
    if Gp != "F(a,b)" :
        print("Wrong group!")
    if Gp == "F(a,b)" :
        break
print()
print("Choose your set X of words in F(a,b) (each pair of words must be entered by a space).")
s_A = input("X: ")
S_A = s_A.split() # Alice: A = {a_{1},...,a_{n}}
#print("A:",S_A)
print()
s_B = input("Receive (each pair of words must be entered by a space): ")
S_B = s_B.split() # Bob: B = {b_{1},...,b_{m}}
#print("B:",S_B)

print()

# 2. Alice picks a secret word a in A, and Bob picks a secret word b in B.
while True :
    print("Choose a secret word s in X, where s = k_{1}w_{1}...k_{n}w_{n} for some positive integer k_{i} and w_{i} in X for all 1 <= i <= n.")
    s = getpass.getpass()
    #print(s)
    a, W, K = f(s) # Recall that f() returns 3 things
    #print(a)
    if re.findall("^[a-zA-Z]",s) or re.findall("[0-9]$",s) :
        print("Wrong format!\n")
    else :
        break

print()

# 3. Alice sends publicly the freely reduced conjugates b_{1}^{a},...,b_{m}^{a} to Bob, and receives the freely reduced conjugates a_{1}^{b},...,a_{n}^{b} from Bob.
NF_A = list()
for b_j in S_B :
    w = conjugate(b_j,a) # b_{1}^{a},...,b_{m}^{a}
    w = reduce(w) # freely reduce b_{1}^{a},...,b_{m}^{a}
    NF_A.append(w)
    #print(w)
print("Send:",NF_A)
print()
s = input("Receive (each pair of words must be entered by a space): ")
NF_B = s.split() # freely reduced conjugates a_{1}^{b},...,a_{n}^{b}
#print("Receive:",NF_B)

print()

# 4. Alice computes a^{b} to obtain the secret common key k = [a,b] = a(a^{b})^{-1}.
L1 = list()
for word, k_i in zip(W, K) :
    i = S_A.index(word)
    w_i = NF_B[i] # w_i = a_{i}^{b} for some i in [1,n] s.t. a_{i}^{k_{i}} in a
    w = k_i * w_i # w = (a_{i}^{k_i})^{b}
    #print("(a_{i}^{k_i})^{b}:",w)
    L1.append(w)
#print("Components in a^{b}:",L1)
c = "".join(L1)
#print("a^{b}:",c)
k_a = reduce(a + inverse(c)) # Alice: the freely reduced a(a^{b})^{-1}
print("The secret common key:",k_a)

print()
